{"ts":1356700673731,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// not relevant on an Arduino\r\n//int PwmCnt;\r\n// The duty on the PWM cycle\r\nint duty;\r\n\r\n/*\r\n* Pin Changes\r\n* Pin 0 and 1 on Arduino cannot be used during testing as they're used for serial comms\r\n*/\r\n\r\n// Right motor CW\r\n#define RightC 0\r\n// Right motor CCW\r\n#define RightCC 1\r\n// Right motor go\r\n#define RightPwr 2\r\n\r\n// Left motor CW\r\n#define LeftC 0\r\n// Left motor CCW\r\n#define LeftCC 1\r\n// Left motor go\r\n#define LeftPwr 2\r\n\r\n#define CW 1\r\n#define CCW 0\r\n\r\n/**\r\n * Does what it says on the tin, sets up the initial state of the system.\r\n */\r\nvoid setup()\r\n{\r\n    //PWM Vars\r\n\tduty = 80;\r\n\t//PwmCnt = 0;\r\n\t\r\n\t// initialise the motor power pins\r\n\tQuit();\r\n\t\r\n\t// Setup the PWM outputs\r\n\tanalogWrite(RightPwr, 0);\r\n\tanalogWrite(LeftPwr, 0);\r\n\t\r\n\tsense_init();\r\n}\r\n\r\n/**\r\n * Default arduino loop. It's called repeatedly.\r\n */\r\nvoid loop()\r\n{\r\n\t// Read the sensors\r\n\tint sensor_results[4] = {Read_3204(0), Read_3204(1), Read_3204(2), Read_3204(3)};\r\n\t// Calculate mean sensor value\r\n\tint mean = 0;\r\n\t// For every sensor we have...\r\n\tfor(int i=0; i<=3; i++)\r\n\t{\r\n\t\t// ...  add it's value to our mean\r\n\t\tmean += sensor_results[i];\r\n\t}\r\n\t// now divide our mean up nicely so it's actually the mean!\r\n\tmean = mean >> 2; // divides mean by 2^2 (i.e. by 4)\r\n\t// Move in the direction of our oddest (furthest from mean) sensor\r\n\tint mostOff;\r\n\t// just a tmp var\r\n\tint offBy;\r\n\tfor(int i=0;i<=3;i++)\r\n\t{\r\n\t\toffBy = sensor_results[i] - mean;\r\n\t\tabs(offBy);\r\n\t\tif(offBy > sensor_results[mostOff])\r\n\t\t{\r\n\t\t\tmostOff = i;\r\n\t\t}\r\n\t}\r\n\t// @todo Don't bother with mostOff if it's only a little bit different\r\n\tswitch(mostOff)\r\n\t{\r\n\t\tcase 0:\r\n\t\t\t// move left\r\n\t\t\tLeft();\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\t// if closer to sensor 0, move left\r\n\t\t\tif(abs(mostOff - sensor_results[0]) > abs(mostOff - sensor_results[2]))\r\n\t\t\t{\r\n\t\t\t\tLeft();\r\n\t\t\t}\r\n\t\t\t// if closer to sensor 2, move forward\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tForward();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\t// if closer to sensor 3, move right\r\n\t\t\tif(abs(mostOff - sensor_results[3]) > abs(mostOff - sensor_results[1]))\r\n\t\t\t{\r\n\t\t\t\tRight();\r\n\t\t\t}\r\n\t\t\t// if closer to sensor 1, move forward\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tForward();\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\t// move right\r\n\t\t\tRight();\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\n/**\r\n* void Quit\r\n* Kills the motor power. (H-bridge stopping trick courtesy of Mark)\r\n*/\r\nvoid Quit()\r\n{\r\n\tdigitalWrite(RightC, LOW);\r\n\tdigitalWrite(RightCC, LOW);\r\n\tdigitalWrite(LeftC, LOW);\r\n\tdigitalWrite(LeftCC, LOW);\r\n}\r\n\r\n/**\r\n* void Forward\r\n* Drives the bot forward.\r\n*/\r\nvoid Forward()\r\n{\r\n\tDrive(CCW, CCW);\r\n}\r\n\r\n/**\r\n* void Left\r\n* Drives the bot Left.\r\n*/\r\nvoid Left()\r\n{\r\n\tDrive(CW, CCW);\r\n}\r\n\r\n/**\r\n* void Backward\r\n* Drives the bot backward.\r\n*/\r\nvoid Backward()\r\n{\r\n\tDrive(CW, CW);\r\n}\r\n\r\n/**\r\n* void Right\r\n* Drives the bot right.\r\n*/\r\nvoid Right()\r\n{\r\n\tDrive(CCW, CW);\r\n}\r\n\r\n/**\r\n* Motor Driving functions\r\n*/\r\n\r\n/**\r\n* Drive\r\n* @param int LeftDirection CW or CCW for left motor\r\n* @param int RightDirection CW or CCW for right motor\r\n*/\r\nvoid Drive(int LeftDirection, int RightDirection)\r\n{\r\n\tdigitalWrite(RightC, RightDirection == CW ? HIGH : LOW);\r\n\tdigitalWrite(RightCC, RightDirection == CW ? LOW : HIGH);\r\n\t\r\n\tdigitalWrite(LeftC, LeftDirection == CW ? HIGH : LOW);\r\n\tdigitalWrite(LeftCC, LeftDirection == CW ? LOW : HIGH);\r\n\t\r\n\t//PWM Vars\r\n\tduty = 80;\r\n\r\n\tanalogWrite(RightPwr, duty);\r\n\tanalogWrite(LeftPwr, duty);\r\n\t//DriveRLoop();\r\n\t//DriveLLoop();\r\n}\r\n\r\n/*void DriveRLoop()\r\n{\r\n\tPwmCnt = 0;\r\n\twhile(PwmCnt <= 20)\r\n\t{\r\n\t\tPwmCnt ++;\r\n\t\t// @todo PWM RightPwr, duty\r\n\t\tanalogWrite(RightPwr, duty);\r\n\t}\r\n}\r\n\r\n// do the pwm on the left motor\r\nvoid DriveLLoop()\r\n{\r\n\tPwmCnt = 0;\r\n\twhile(PwmCnt <= 20)\r\n\t{\r\n\t\tPwmCnt ++;\r\n\t\t// @todo PWM LeftPwr, duty\r\n\t}\r\n}*/\r\n\r\n/**\r\n* Sensor Reader\r\n* MCP3204 12-bit 4-channel ADC\r\n*/\r\n// MCP3204.8\r\n#define CS 15\r\n// MCP3204.9\r\n#define DIN 14\r\n// MCP3204.10\r\n#define DOUT 13\r\n// MCP3204.11\r\n#define CLK 12\r\n\r\n// list of channels\r\n//const char chans[] = {0xC, 0xD, 0xE, 0xF};\r\n\r\n\r\n//------------- ADC READ FUNCTION----------------\r\nint Read_3204(int channel){\r\n  int adcvalue = 0;\r\n  byte commandbits = B11000000; //command bits - start, mode, chn (3), dont care (3)\r\n\r\n  //allow channel selection\r\n  commandbits|((channel-1)<<3);\r\n   //digitalWrite(CS,HIGH);\r\n  digitalWrite(CS,LOW); //Select adc\r\n  // setup bits to be written\r\n  for (int i=7; i>=3; i--){\r\n    digitalWrite(DOUT,commandbits&1<<i);\r\n    //cycle clock\r\n    digitalWrite(CLK,HIGH);\r\n    digitalWrite(CLK,LOW);    \r\n  }\r\n\r\n  digitalWrite(CLK,HIGH);    //ignores 2 null bits\r\n  digitalWrite(CLK,LOW);\r\n  digitalWrite(CLK,HIGH);  \r\n  digitalWrite(CLK,LOW);\r\n\r\n  //read bits from adc\r\n  for (int i=11; i>=0; i--){\r\n    adcvalue+=digitalRead(DIN)<<i;\r\n    //cycle clock\r\n    digitalWrite(CLK,HIGH);\r\n    digitalWrite(CLK,LOW);\r\n  }\r\n  digitalWrite(CS, HIGH); //turn off device\r\n  //digitalWrite(CS,LOW);\r\n  return adcvalue;\r\n}\r\n\r\nvoid sense_init()\r\n{\r\n\tdigitalWrite(CS, HIGH);\r\n}"]],"start1":0,"start2":0,"length1":0,"length2":4906}]],"length":4906}
